utilizar bepd/builtins
utilizar bepd/x/enum (EnumConValores)
utilizar bepd/x/datos (TipoDeDatos)

[DOCUMENTA
@title{La representación intermediaria del backend de C}

La representación consiste de funciones y continuaciones. Ambas tienen una
secuencia de instrucciones en su interior.

Véase la enumeración @pd{Opcode} para una lista de todas las instrucciones.

Las funciones consisten de un número de parámetros, un número de capturas y su
nombre único. Las continuaciones @bold{no} son funciones.

El IR es una máquina de registros, cada función tiene 2 áreas de registros:
las locales (registros temporales que son locales a la función) y las capturas
(que son asignadas al momento de crear el closure). Las capturas son los
primeros @italic{N} registros de cada función. De forma que si una función tiene
@italic{N} capturas, los registros 0, 1, 2, ..., @italic{N} son capturas y
@italic{N} + 1, @italic{N} + 2, @italic{N} + 3, ... son locales.

Véase la clase @pd{FunciónIR} para más información sobre las funciones.

Véase la clase @pd{ContinuaciónIR} para más información sobre las
continuaciones.

Un programa es un conjunto de funciones y continuaciones con una "función
principal". Esta es la función que será llamada al iniciar el programa.

@subtitle{Tipos de datos}

Los registros locales pueden almacenar valores de cualquier tipo. Estos
tipos son los mismos que en PseudoD (enteros, reales, textos,
booleanos, funciones, objetos, tablas hash, etc), pero además, existe un tipo
"caja". Conceptualmente esta caja es igual a la clase @pd(#:utilizar
"bepd/datos/caja"){Caja} de la BEPD, pero no tiene métodos y es un detalle de
la implementación. Las continuaciones @bold{no son de primera clase} lo que
significa que no hay un "tipo de continuación".

Una instrucción es un arreglo cuyo primer elemento es un @pd{Opcode}. Los demás
elementos son los "argumentos" de la instrucción. Estos arreglos son llamados
"tuplas".

@subtitle{Estructura del código}

El código generado sigue ciertos patrones importantes. Algunos de estos son:

@bold{Preludio de función}: Las funciones suelen comenzar con el siguiente
patrón:

@codeblock|{
; Una función con 3 argumentos normales y 1 variadic.
; Corresponde con el código de PseudoD: `funcion ejemplo: A, B, C, ...D`
función 0 capturas 0 locales 4
    params VERDADERO, 3, {0, 1, 2, 3}
    ...cuerpo...
    devolverN 1
finfuncion
}|

@bold{Importar y exportar}: El final de cada módulo tiene mas o menos la
siguiente forma:

@codeblock|{
crearEspacioDeNombres 10 ; local con el espacio de nombres
agregarNombre 10, 0, {ejemplo1}, FALSO ; exporta el registro 0
agregarNombre 10, 1, {ejemplo2}, VERDADERO ; es autoejecutable
exportar 10
}|

Similarmente, al importar un módulo el patrón es:

@codeblock|{
importar 10, {prefijoDelMódulo}
extraer 0, 10, {ejemplo1} ; fija el registro #0 al nombre {ejemplo1}
extraer 1, 10, {ejemplo2}
comoEspacioDeNombres 2, 10 ; registro #2 = espacio de nombres de #10
}|

@toplevel()
DOCUMENTA]


[DOCUMENTA
@brief{El tipo de una instrucción.}

@bold{Nota}: si alguna instrucción requiere una continuación, esto @bold{no}
será indicado. Si alguna instrucción requiere una etiqueta, el argumento debe
ser de tipo @pd{Etiqueta}.

@enum(

@defenum("csaltar"){Salta condicionalmente a una de dos etiquetas. Pide
el registro determinante y las dos etiquetas.}

@defenum("saltar"){Salta incondicionalmente a una etiqueta. Pide un argumento:
la etiqueta a la que saltar.}

@defenum("enviarMensaje_s1"){Envía un mensaje a un objeto. Toma 4 argumentos:
un arreglo de @pd{Retorno}s con los registros que tendrán los valores de retorno,
el registro con el objeto que usar, el mensaje a enviar (un @pd{Texto}) y
el "prototipo" de la llamada (un arreglo de @pd{Argumento}s). Debe ser
seguido de @code{enviarMensahe_s2}.}

@defenum("enviarMensaje_s2"){La segunda etapa de @code{enviarMensaje_s1}.}

@defenum("etiqueta"){Marca una etiqueta. Su único argumento debe ser una
@pd{Etiqueta}.}

@defenum("fijarRegistro"){Toma dos registros, y le asigna el valor del
segundo al primero.}

@defenum("caja"){Toma dos argumento: el registro en la que guardar la caja y el
registro a envolver en una caja.}

@defenum("fijarCaja"){Toma dos argumentos: el registro con la caja que será cambiada
y el registro con el nuevo valor.}

@defenum("valorDeCaja"){Toma dos argumentos: el registro en la que se guardará el
valor y el registro con la caja a abrir.}

@defenum("prn"){Escribe el valor del registro dado.}

@defenum("prnl"){Escribe un fin de línea. No acepta argumentos.}

@defenum("assert"){Obtiene el valor del registro dado (su único argumento), si
es verdadero no hace nada, pero si es falso falla con un error.}

@defenum("devolverN"){Toma como único argumento un arreglo de @pd{Retorno}s
con los valores a devolver.}

@defenum("número"){Acepta dos argumentos: el registro a fijar y el @pd{Numero} a
usar.}

@defenum("texto"){Acepta dos argumentos: el registro a fijar y el texto, que es
empujado en la pila.}

@defenum("nulo"){Fija un registro (su único argumento) a @pd{NULO}}

@defenum("negar"){Toma dos registros. Fija el primero a la negación del segundo
(un booleano).}

@defenum("sonIdénticos"){Determina si dos registros (segundo y tercer
argumentos) contienen valores idénticos. El resultado se almacena en el
primer argumento (otro registro).}

@defenum("obtenerObjeto"){Fija un registro a la clase @pd{Objeto}.}

@defenum("mkclz"){Crea una @italic{closure}. Acepta 3 argumentos: el
primero es el registro en el que se guardará la closure, el segundo es
el ID de la función a usar (un entero) y el tercero es un arreglo de los
registros a usar como capturas.}

@defenum("continuar"){Salta a una continuación. Acepta un argumento, el nombre
de la continuación a la que saltar (un entero).}

@defenum("espacioDeNombres"){Crea un nuevo espacio de nombres y lo guarda
en el registro dado (su único argumento).}

@defenum("agregarNombre"){Agrega un nombre a un espacio de nombres. Acepta
4 argumentos: el registro con el espacio de nombres, el registro con el valor,
el nombre a agregar (un @pd{Texto}) y un @pd{Boole} que indica si es autoejecutable
o no.}

@defenum("exportar"){Exporta el espacio de nombres que esta en el registro
dado.}

@defenum("obtenerRuntime"){Obtiene el objeto "runtime". Fija su único argumento
(un registro) a dicho objeto.}

@defenum("importar_s1"){Acepta dos argumentos: el registro en el que guardar el
módulo y el prefijo del módulo a importar (un texto). @bold{Nota}: Debes
usar @code{comoEspacioDeNombres} para convertir el valor importado a un
espacio de nombres. Esta instrucción tiene que ser seguida por
@code{importar_s2}.}

@defenum("importar_s2"){Segunda etapa de @code{importar_s1}. Acepta los mismos
parámetros.}

@defenum("extraer_s1"){Extrae un nombre de un valor importado (el resultado de
importar un módulo). Acepta 3 valores: el registro a fijar con el valor,
el registro con el módulo y el nombre a extraer (un @pd{Texto}). Esta
instrucción tiene que ser seguida por @code{extraer_s2}.}

@defenum("extraer_s2"){Segunda etapa de @code{extraer_s1}. Acepta los mismos
parámetros.}

@defenum("obtenerEspacioDeNombresDelRuntime"){Fija el registro dado (su
único argumento) al espacio de nombres del runtime.}

@defenum("comoEspacioDeNombres"){Acepta dos argumentos: el registro que
tendrá el espacio de nombres y el registro con el módulo (se debe usar con
el valor devuelto por el opcode @code{importar}).}
)
DOCUMENTA]
variable Opcode
fijar Opcode a EnumConValores: {Opcode},
    [ Nombre del opcode,                 ¿Requiere una continuación? ]
    {csaltar},                           VERDADERO,
    {saltar},                            VERDADERO,
    {enviarMensaje_s1},                  VERDADERO,
    {enviarMensaje_s2},                  FALSO,
    {etiqueta},                          VERDADERO,
    {fijarRegistro},                     FALSO,
    {caja},                              FALSO,
    {fijarCaja},                         FALSO,
    {valorDeCaja},                       FALSO,
    {prn},                               FALSO,
    {prnl},                              FALSO,
    {assert},                            FALSO,
    {devolverN},                         FALSO,
    {número},                            FALSO,
    {texto},                             FALSO,
    {nulo},                              FALSO,
    {negar},                             FALSO,
    {sonIdénticos},                      FALSO,
    {obtenerObjeto},                     FALSO,
    {mkclz},                             FALSO,
    {continuar},                         FALSO,
    {espacioDeNombres},                  FALSO,
    {agregarNombre},                     VERDADERO,
    {exportar},                          FALSO,
    {obtenerRuntime},                    FALSO,
    {importar_s1},                       VERDADERO,
    {importar_s2},                       FALSO,
    {extraer_s1},                        VERDADERO,
    {extraer_s2},                        FALSO,
    {obtenerEspacioDeNombresDelRuntime}, FALSO,
    {comoEspacioDeNombres},              FALSO

[DOCUMENTA
@brief{Determina si el opcode requiere una continuación.}

Si el opcode requiere una continuación, su último argumento debe ser el nombre
de la continuación (un entero) a la que saltar.

@devuelve{@pd{VERDADERO} o @pd{FALSO}}.
DOCUMENTA]
metodo Opcode#requiereContinuación
    devolver yo#valor
finmetodo


[DOCUMENTA
@brief{Representa un parámetro de una función en el IR.}

@code{esVariadic} determina si el parámetro es variadic. Solo puede haber
un solo parámetro variadic por función.

@code{registro} es el registro a usar.
DOCUMENTA]
variable Parámetro
fijar Parámetro a TipoDeDatos: {Parámetro}, {esVariadic}, {registro}


[DOCUMENTA
@brief{Representa un argumento en el IR.}

@code{esVariadic} determina si el argumento es un arreglo que debería ser
expandido en varios argumentos adicionales.

@code{registro} es el registro a usar.
DOCUMENTA]
variable Argumento
fijar Argumento a TipoDeDatos: {Argumento}, {esVariadic}, {registro}


[DOCUMENTA
@brief{Representa un valor de retorno de una función en el IR.}

@code{esVariadic} determina si el valor de retorno es un arreglo que debería
ser expandido en varios valores de retorno adicionales.

@code{registro} es el registro a devolver.
DOCUMENTA]
variable Retorno
fijar Retorno a TipoDeDatos: {Retorno}, {esVariadic}, {registro}


[DOCUMENTA
@brief{Una etiqueta a la que saltar en el IR.}

Las etiquetas tienen un ID, que es un entero que las
identifica. Específicamente: el ID de las etiquetas es el ID de la
@italic{continuación} a la que se debe saltar para "ir" a la etiqueta.

Véase el método @pd(#:utilizar "pdc/backend/c"){Emisor#ajustarEtiqueta}, que le
asigna un ID a una etiqueta.
DOCUMENTA]
clase Etiqueta
    [DOCUMENTA
    @brief{El ID de la etiqueta.}

    Puede ser @pd{NULO} si la etiqueta no ha sido ajustada.
    DOCUMENTA]
    atributo id

    [DOCUMENTA
    @brief{Crea una nueva etiqueta vacía.}

    El ID de la etiqueta es @pd{NULO}.
    DOCUMENTA]
    metodo estatico vacía

    [DOCUMENTA
    @brief{Devuelve una representación textual de la etiqueta.}
    DOCUMENTA]
    metodo comoTexto
finclase

metodo estatico Etiqueta#vacía
    devolver yo#crear
finmetodo

metodo Etiqueta#comoTexto
    devolver {etq:~t}#formatear: yo#id
finmetodo


[DOCUMENTA
@brief{Una función en el IR.}

Las funciones tienen un número de parámetros y un número de capturas. Las
capturas son valores guardados al momento de crear el closure y son accesibles
en cada ejecución de la función. Además, las funciones estan identificadas por
un ID, un número entero que es su nombre.
DOCUMENTA]
clase FunciónIR
    [DOCUMENTA
    @brief{ID (nombre) de la función.}

    Un entero.
    DOCUMENTA]
    atributo id

    [DOCUMENTA
    @brief{@pd{Arreglo} con las instrucciones de la función.}
    DOCUMENTA]
    atributo instrucciones

    [DOCUMENTA
    @brief{Número de locales.}
    DOCUMENTA]
    atributo númLocales

    [DOCUMENTA
    @brief{Número de capturas.}
    DOCUMENTA]
    atributo númCapturas

    [DOCUMENTA
    @brief{@pd{Parámetro}s de la función.}
    DOCUMENTA]
    atributo parámetros

    [DOCUMENTA
    @brief{Crea y devuelve una nueva función.}
    DOCUMENTA]
    metodo estatico crear: parámetros, númLocales, númCapturas, instrucciones
finclase

metodo FunciónIR#inicializar: parámetros, númLocales, númCapturas, instrucciones
    fijar yo#instrucciones a instrucciones
    fijar yo#númLocales a númLocales
    fijar yo#númCapturas a númCapturas
    fijar yo#parámetros a parámetros
finmetodo

metodo FunciónIR#númRegistros
    devolver yo#númLocales + yo#númCapturas
finmetodo


[DOCUMENTA
@brief{Una continuación del IR.}

LAs continuaciones solo poseen un ID (un entero) que las identifica y un
arreglo de instrucciones.
DOCUMENTA]
clase ContinuaciónIR
    [DOCUMENTA
    @brief{ID de la continuación.}
    DOCUMENTA]
    atributo id

    [DOCUMENTA
    @brief{@pd{Arreglo} con las instrucciones.}
    DOCUMENTA]
    atributo instrucciones
finclase

metodo ContinuaciónIR#inicializar: instrucciones
    fijar yo#instrucciones a instrucciones
finmetodo


[DOCUMENTA
@brief{}
DOCUMENTA]
clase ProgramaIR
    [DOCUMENTA
    @brief{Entero con el ID de la función principal.}

    La función principal es la que se debe ejecutar al importar el módulo.
    DOCUMENTA]
    atributo idDeLaFunciónPrincipal

    [DOCUMENTA
    @brief{Arreglo con todas las funciones.}
    DOCUMENTA]
    atributo funciones

    [DOCUMENTA
    @brief{Arreglo con todas las continuaciones.}
    DOCUMENTA]
    atributo continuaciones

    [DOCUMENTA
    @brief{Crea y devuelve un nuevo programa.}

    Véase los atributos de los mismos nombres de los argumentos.
    DOCUMENTA]
    metodo estatico crear: idDeLaFunciónPrincipal, funciones, continuaciones
finclase

metodo ProgramaIR#inicializar: idDeLaFunciónPrincipal, funciones, continuaciones
    fijar yo#idDeLaFunciónPrincipal a idDeLaFunciónPrincipal
    fijar yo#funciones a funciones
    fijar yo#continuaciones a continuaciones
finmetodo

[DOCUMENTA
@brief{Escribe una representación textual del programa.}

Principalmente útil al depurar.
DOCUMENTA]
procedimiento EscribirPrograma: programa
    procedimiento escribirInstrucciones: pref, instrs
        ParaCadaElemento: instrs, procedimiento: instr
            escribir pref#comoTexto
            escribir {    }
            escribir (instr#en: 0)#nombre
            ParaCadaNúmero: 1, instr#longitud, procedimiento: i
                escribir {	}
                escribir (instr#en: i)#comoTexto
            finprocedimiento
            nl
        finprocedimiento
    finprocedimiento

    Escribir: {.principal}, programa#idDeLaFunciónPrincipal
    Escribir: {.funciones}
    ParaCadaElemento: programa#funciones, procedimiento: func
        Escribir: {  .func}, func#id, func#númCapturas, func#númLocales
        escribirInstrucciones: {  }, func#instrucciones
    finprocedimiento
    Escribir: {.continuaciones}
    ParaCadaElemento: programa#continuaciones, procedimiento: k
        Escribir: {  .cont}, k#id
        escribirInstrucciones: {  }, k#instrucciones
    finprocedimiento
finprocedimiento
