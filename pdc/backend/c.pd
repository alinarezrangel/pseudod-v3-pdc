utilizar bepd/builtins
utilizar bepd/datos/caja (Caja)
utilizar bepd/x/adhoc (ObjetoAdHoc)
utilizar bepd/x/sistemaDeArchivos/archivo (LeerArchivo)

utilizar pdc/ast como AST
utilizar pdc/nombres (TablasDeResoluciónDeNombres)
utilizar pdc/capturas (TablasDeCapturas)
utilizar pdc/tabla (EscribirTabla)
utilizar pdc/backend/c/ir (Opcode, FunciónIR, Parámetro, Argumento, Retorno, Etiqueta, ContinuaciónIR, ProgramaIR, EscribirPrograma)
utilizar pdc/info (IMPL_COMPILADOR)


[DOCUMENTA
@brief{Emisor del IR de C.}

Véase el módulo @code{pdc/backend/c/ir} para una descripción del la
representación intermediaria.

Lleva registro de las continuaciones, las funciones y las instrucciones del
programa.

El emisor actúa como un arreglo de instrucciones. Estas instrucciones pueden
ser movidas a una función (mediante el método @code{#moverAFunción}) o a un
nuevo programa (mediante el método @code{#moverAPrograma}).
DOCUMENTA]
clase Emisor
    [DOCUMENTA
    @brief{Crea un nuevo emisor.}
    DOCUMENTA]
    metodo estatico crear

    [DOCUMENTA
    @brief{Crea un nuevo subemisor.}

    Los dos emisores (el devuelto y @pd{emisorPadre}) comparten funciones
    y continuaciones.
    DOCUMENTA]
    metodo estatico subEmisor: emisorPadre

    [DOCUMENTA
    @brief{Emite una instrucción.}

    @pd{opcode} es el opcode (un @pd{Opcode}) a emitir, mientras que @pd{args}
    son los argumentos del mismo. El tipo de @pd{args} depende del opcode dado,
    véase la documentación del IR para más información.

    Si la instrucción requiere una continuación, esta será agregada
    automáticamente al final de los argumentos. Por ejemplo, para emitir el
    opcode @pd(#:utilizar "pdc/backend/c/ir"){Opcode#enviarMensaje} que pide
    tres argumentos: el mensaje, el prototipo y la continuación, tu solo llamas
    a emitir con dos: el mensaje y el prototipo. La continuación será agregada
    al final de forma automática.
    DOCUMENTA]
    metodo emitir: opcode, ...args

    [DOCUMENTA
    @brief{Mueve todo el código emitido hasta ahora a una función nueva.}

    @pd{params} son los @pd{Parámetro}s de la función. @pd{númTotalLocales} es el
    número de locales de la función.

    Devuelve la @pd{FunciónIR} creada.
    DOCUMENTA]
    metodo moverAFunción: params, númTotalLocales, númCapturas

    [DOCUMENTA
    @brief{Mueve todo el código, funciones y continuaciones a un programa
    nuevo.}

    El programa creado es devuelto y guardado en el emisor. Véase
    @pd{Emisor#programa}.
    DOCUMENTA]
    metodo moverAPrograma: númTotalLocales, númCapturas

    [DOCUMENTA
    @brief{Ajusta una etiqueta ya emitida para que apunte a la posición
    actual.}

    @pd{etiqueta} debe ser una @pd{Etiqueta} ya fue emitida.
    DOCUMENTA]
    metodo ajustarEtiqueta: etiqueta

    [DOCUMENTA
    @brief{Devuelve el programa generado.}

    Solo se puede llamar después de llamar @code{#moverAPrograma}. Devuelve
    el @pd{ProgramaIR}.
    DOCUMENTA]
    metodo programa
finclase

atributos Emisor#instrucciones, Emisor#idDeContinuaciónActual,
          Emisor#funciones, Emisor#continuaciones, Emisor#idDeFunción,
          Emisor#idDeContinuación, Emisor#_programa, Emisor#cabecera

metodo estatico Emisor#subEmisor: emisorPadre
    variable c
    fijar c a yo#crear
    fijar c#funciones a emisorPadre#funciones
    fijar c#continuaciones a emisorPadre#continuaciones
    fijar c#idDeFunción a emisorPadre#idDeFunción
    fijar c#idDeContinuación a emisorPadre#idDeContinuación
    fijar c#_programa a emisorPadre#_programa
    devolver c
finmetodo

metodo Emisor#inicializar
    fijar yo#instrucciones a Arreglo#vacio
    fijar yo#cabecera a yo#instrucciones
    fijar yo#funciones a Arreglo#vacio
    fijar yo#continuaciones a Arreglo#vacio
    fijar yo#idDeContinuaciónActual a NULO
    fijar yo#idDeFunción a Caja#crear: 0
    fijar yo#idDeContinuación a Caja#crear: 0
    fijar yo#_programa a Caja#crear: NULO
finmetodo

metodo Emisor#emitir: ...tupla
    necesitas tupla#longitud > 0
    variable opcode
    fijar opcode a tupla#en: 0
    si son diferentes opcode y Opcode#etiqueta
        yo#instrucciones#agregarAlFinal: tupla
    finsi
    si opcode#requiereContinuación
        variable k
        fijar k a ContinuaciónIR#crear: Arreglo#vacio
        fijar k#id a yo#idDeContinuación#valor
        fijar yo#idDeContinuaciónActual a k#id
        fijar yo#idDeContinuación#valor a yo#idDeContinuación#valor + 1
        si opcode = Opcode#etiqueta
            yo#instrucciones#agregarAlFinal: (Arreglo#crearCon: Opcode#continuar, k#id)
        finsi
        tupla#agregarAlFinal: k#id
        fijar yo#instrucciones a k#instrucciones
        yo#continuaciones#agregarAlFinal: k
    finsi
finmetodo

metodo Emisor#moverAFunción: params, númTotalLocales, númCapturas
    variable func
    fijar func a FunciónIR#crear: params, númTotalLocales, númCapturas, yo#cabecera
    fijar func#id a yo#idDeFunción#valor
    fijar yo#idDeFunción#valor a yo#idDeFunción#valor + 1
    yo#funciones#agregarAlFinal: func
    fijar yo#instrucciones a Arreglo#vacio
    fijar yo#cabecera a yo#instrucciones
    fijar yo#idDeContinuaciónActual a NULO
    devolver func
finmetodo

metodo Emisor#moverAPrograma: númTotalLocales, númCapturas
    variables funcPrincipal, prog
    fijar funcPrincipal a yo#moverAFunción: Arreglo#vacio, númTotalLocales, númCapturas
    fijar prog a ProgramaIR#crear: funcPrincipal#id, yo#funciones, yo#continuaciones
    fijar yo#_programa#valor a prog
    devolver prog
finmetodo

metodo Emisor#ajustarEtiqueta: etiqueta
    yo#emitir: Opcode#etiqueta, etiqueta
    fijar etiqueta#id a yo#idDeContinuaciónActual
finmetodo

metodo Emisor#programa
    necesitas no EsNulo: yo#_programa#valor
    devolver yo#_programa#valor
finmetodo


[DOCUMENTA
@brief{Escribe una representación textual del emisor.}

Principalmente útil al depurar.
DOCUMENTA]
procedimiento EscribirEmisor: emisor
    procedimiento escribirInstrucciones: pref, instrs
        ParaCadaElemento: instrs, procedimiento: instr
            escribir pref#comoTexto
            escribir {    }
            escribir (instr#en: 0)#nombre
            ParaCadaNúmero: 1, instr#longitud, procedimiento: i
                escribir {	}
                escribir (instr#en: i)#comoTexto
            finprocedimiento
            nl
        finprocedimiento
    finprocedimiento

    Escribir: {.instrucciones}
    escribirInstrucciones: {}, emisor#instrucciones
    Escribir: {.funciones}
    ParaCadaElemento: emisor#funciones, procedimiento: func
        Escribir: {  .func}, func#id, func#númCapturas, func#númLocales
        escribirInstrucciones: {  }, func#instrucciones
    finprocedimiento
    Escribir: {.continuaciones}
    ParaCadaElemento: emisor#continuaciones, procedimiento: k
        Escribir: {  .cont}, k#id
        escribirInstrucciones: {  }, k#instrucciones
    finprocedimiento
finprocedimiento


[DOCUMENTA
@brief{Itera sobre cada elemento del arreglo al revés.}

Comienza por el último elemento (@pd{arr#longitud - 1}) y llega hasta el
primero (@pd{0}). Con cada elemento, llama a @pd{proc} con dos argumentos: el
elemento y el índice del mismo.
DOCUMENTA]
procedimiento ParaCadaElementoEnReversaConÍndice: arr, proc
    ParaCadaNúmero: 0, arr#longitud, procedimiento: i
        variable j
        fijar j a (arr#longitud - 1) - i
        devolver %proc: (arr#en: j), j
    finprocedimiento
finprocedimiento


[DOCUMENTA
@brief{Clase que compila un AST ya anotado y analizado a un IR.}
DOCUMENTA]
clase EstadoDeEmisión
    [DOCUMENTA
    @brief{Crea un compilador a IR en su estado inicial.}

    @params(
    @defparam(tablasRnAst){La @pd{TablasDeResoluciónDeNombres} del AST.}
    @defparam(tablasMcAst){La @pd{TablasDeCapturas} del AST.}
    @defparam(emisor){El @pd{Emisor} en el que se escribirá el código.}
    @defparam(bdMod){La @pd(#:utilizar "pdc/módulos"){BaseDeDatosDeMódulos}
    a usar.}
    )

    @devuelve{El estado de emisión.}
    DOCUMENTA]
    metodo estatico inicial: tablasRnAst, tablasMcAst, emisor, bdMod

    [DOCUMENTA
    @brief{Compila un fragmento del AST.}

    Para compilar un programa, debería ser un @pd{AST#NodoPrograma}.

    @devuelve{Nada, el resultado estará guardado en el emisor del estado.}
    DOCUMENTA]
    metodo emitir: ast
finclase

atributos EstadoDeEmisión#tablasRnAst, EstadoDeEmisión#tablasMcAst,
          EstadoDeEmisión#emisor,
          [ Diccionario que mapea cada binding local a su índice de local. ]
          EstadoDeEmisión#locales,
          [ Diccionario que mapea cada binding local a su índice de captura. ]
          EstadoDeEmisión#capturas,
          EstadoDeEmisión#bdMod,
          [ Índice de la local actual de la pila.

            Por motivos de simplicidad, el compilador utiliza una pila de
            locales para almacenar los valores temporales en el programa.
            Imagínalo como una pila de enteros con las locales en uso:
            {1 2 3} + empujar -> {1 2 3 4}.

            Esto puede ser simplificado a un único número: el offset de la
            local en la cima de la pila. Eso es lo que representa este atributo:
            3 + empujar -> 4.
           ]
          EstadoDeEmisión#localesTemporales,
          EstadoDeEmisión#númTotalTemporales

metodo estatico EstadoDeEmisión#inicial: tablasRnAst, tablasMcAst, emisor, bdMod
    devolver yo#crear: tablasRnAst, tablasMcAst, emisor, bdMod
finmetodo

metodo EstadoDeEmisión#inicializar: tablasRnAst, tablasMcAst, emisor, bdMod
    fijar yo#tablasRnAst a tablasRnAst
    fijar yo#tablasMcAst a tablasMcAst
    fijar yo#emisor a emisor
    fijar yo#locales a Diccionario#vacío
    fijar yo#capturas a Diccionario#vacío
    fijar yo#bdMod a bdMod
    fijar yo#localesTemporales a 0
    fijar yo#númTotalTemporales a 0
finmetodo

metodo EstadoDeEmisión#subestado: emisor, locales, capturas
    variable sub
    fijar sub a EstadoDeEmisión#crear
    fijar sub#tablasRnAst a yo#tablasRnAst
    fijar sub#tablasMcAst a yo#tablasMcAst
    fijar sub#emisor a emisor
    fijar sub#locales a locales
    fijar sub#capturas a capturas
    fijar sub#bdMod a yo#bdMod
    fijar sub#localesTemporales a 0
    fijar sub#númTotalTemporales a 0
    devolver sub
finmetodo

metodo EstadoDeEmisión#localARegistro: nLocal
    necesitas 0 =< nLocal && nLocal < yo#locales#longitud
    devolver yo#capturas#longitud + nLocal
finmetodo

metodo EstadoDeEmisión#capturaARegistro: nCaptura
    necesitas 0 =< nCaptura && nCaptura < yo#capturas#longitud
    devolver nCaptura
finmetodo

metodo EstadoDeEmisión#temporalARegistro: nTemp
    necesitas 0 =< nTemp
    devolver yo#capturas#longitud + yo#locales#longitud + nTemp
finmetodo

metodo EstadoDeEmisión#empujar
    variable res
    fijar res a yo#localesTemporales
    fijar yo#localesTemporales a yo#localesTemporales + 1
    fijar yo#númTotalTemporales a Max: yo#númTotalTemporales, (res + 1)
    devolver yo#temporalARegistro: res
finmetodo

metodo EstadoDeEmisión#sacar
    necesitas yo#localesTemporales > 0
    yo#emisor#emitir: Opcode#nulo, (yo#temporalARegistro: (yo#localesTemporales - 1))
    fijar yo#localesTemporales a yo#localesTemporales - 1
finmetodo

metodo EstadoDeEmisión#sacarRegistro: reg
    necesitas yo#localesTemporales > 0
    necesitas (yo#temporalARegistro: (yo#localesTemporales - 1)) = reg
    fijar yo#localesTemporales a yo#localesTemporales - 1
    yo#emisor#emitir: Opcode#nulo, reg
finmetodo

metodo EstadoDeEmisión#registroEnLaPila: n
    necesitas (0 =< n) && (n < yo#localesTemporales)
    variable p
    fijar p a (yo#localesTemporales - 1) - n
    devolver yo#temporalARegistro: p
finmetodo

metodo EstadoDeEmisión#cima
    devolver yo#registroEnLaPila: 0
finmetodo

metodo EstadoDeEmisión#númTotalLocales
    devolver yo#locales#longitud + yo#númTotalTemporales
finmetodo

metodo EstadoDeEmisión#registroDeBinding: binding
    si yo#locales#contiene: binding
        devolver yo#localARegistro: (yo#locales#en: binding)
    sino
        devolver yo#capturaARegistro: (yo#capturas#en: binding)
    finsi
finmetodo

metodo EstadoDeEmisión#emitirFijarBinding: binding
    variable regValor
    fijar regValor a yo#cima
    si EsNulo: (yo#tablasMcAst#tablaEsCapturada#intentaBuscarÚnico: {binding}, binding)
        yo#emisor#emitir: Opcode#fijarRegistro, (yo#registroDeBinding: binding), regValor
    sino
        yo#emisor#emitir: Opcode#fijarCaja, (yo#registroDeBinding: binding), regValor
    finsi
    yo#sacarRegistro: regValor
finmetodo

metodo EstadoDeEmisión#emitirFijarIdentificador: nodoIdentificador
    variable reg
    fijar reg a yo#tablasRnAst#tablaUsos#intentaBuscarÚnico: {idNodo}, nodoIdentificador#id
    si EsNulo: reg
        fijar reg a yo#tablasRnAst#tablaDefiniciones#buscarÚnico: {idNodo}, nodoIdentificador#id
    finsi
    yo#emitirFijarBinding: reg#binding
    devolver reg#binding
finmetodo

metodo EstadoDeEmisión#emitirObtenerBinding: binding
    variable regRes
    fijar regRes a yo#empujar

    si EsNulo: (yo#tablasMcAst#tablaEsCapturada#intentaBuscarÚnico: {binding}, binding)
        yo#emisor#emitir: Opcode#fijarRegistro, regRes, (yo#registroDeBinding: binding)
    sino
        yo#emisor#emitir: Opcode#valorDeCaja, regRes, (yo#registroDeBinding: binding)
    finsi
finmetodo

metodo EstadoDeEmisión#emitirObtenerIdentificador: nodoIdentificador
    variable reg
    fijar reg a yo#tablasRnAst#tablaUsos#intentaBuscarÚnico: {idNodo}, nodoIdentificador#id
    si EsNulo: reg
        fijar reg a yo#tablasRnAst#tablaDefiniciones#buscarÚnico: {idNodo}, nodoIdentificador#id
    finsi
    yo#emitirObtenerBinding: reg#binding
    devolver reg#binding
finmetodo

funcion ObtenerCapturasYLocales: nodoConCapturas, tablasMcAst
    variables reg, locales, capturas, sub, ordenDeCapturas

    fijar reg a tablasMcAst#tablaCapturas#buscarÚnico: {idNodo}, nodoConCapturas#id
    fijar capturas a Diccionario#vacío
    fijar ordenDeCapturas a Arreglo#vacio
    ParaCadaElementoConÍndice: reg#bindingsCapturados, procedimiento: binding, i
        capturas#fijarEn: binding, i
        ordenDeCapturas#agregarAlFinal: binding
    finprocedimiento

    fijar reg a tablasMcAst#tablaLocales#buscarÚnico: {idNodo}, nodoConCapturas#id
    fijar locales a Diccionario#vacío
    ParaCadaElementoConÍndice: reg#bindingsLocales, procedimiento: binding, i
        locales#fijarEn: binding, i
    finprocedimiento

    devolver ObjetoAdHoc: {locales}, locales,
                          {capturas}, capturas,
                          {ordenDeCapturas}, ordenDeCapturas,
                          {númLocales}, locales#longitud,
                          {númCapturas}, capturas#longitud
finfuncion

metodo EstadoDeEmisión#prepararDeclaración: nodoIdentificador
    variable reg
    fijar reg a yo#tablasRnAst#tablaUsos#intentaBuscarÚnico: {idNodo}, nodoIdentificador#id
    si EsNulo: reg
        fijar reg a yo#tablasRnAst#tablaDefiniciones#buscarÚnico: {idNodo}, nodoIdentificador#id
    finsi
    yo#prepararDeclaraciónConBinding: reg#binding
finmetodo

metodo EstadoDeEmisión#prepararDeclaraciónConBinding: binding
    si EsNulo: (yo#tablasMcAst#tablaEsCapturada#intentaBuscarÚnico: {binding}, binding)
        yo#emisor#emitir: Opcode#nulo, (yo#registroDeBinding: binding)
    sino
        variable regTemp
        fijar regTemp a yo#empujar
        yo#emisor#emitir: Opcode#nulo, regTemp
        yo#emisor#emitir: Opcode#caja, (yo#registroDeBinding: binding), regTemp
        yo#sacarRegistro: regTemp
    finsi
finmetodo

metodo EstadoDeEmisión#emitir: ast
    si EsInstancia: ast, AST#NodoBloque
        ParaCadaElemento: ast#cuerpo, procedimiento: nodo
            si EsInstancia: nodo, AST#NodoVariable
                yo#prepararDeclaración: nodo#nombre
            finsi
            si EsInstancia: nodo, AST#NodoUtilizar
                si no EsNulo: nodo#espacioDeNombres
                    yo#prepararDeclaración: nodo#espacioDeNombres
                finsi

                variable imps
                fijar imps a yo#tablasRnAst#tablaNombresImportados#buscarOrdenado: {idNodo}, nodo#id
                ParaCadaElemento: imps, procedimiento: imp
                    yo#prepararDeclaraciónConBinding: imp#binding
                finprocedimiento
            finsi
        finprocedimiento

        ParaCadaElemento: ast#cuerpo, procedimiento: ast
            yo#emitir: ast
            si ast#esExpresión
                yo#sacar
            finsi
        finprocedimiento
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoPrograma
        variables sub, caps
        fijar caps a ObtenerCapturasYLocales: ast, yo#tablasMcAst
        fijar sub a yo#subestado: yo#emisor, caps#locales, caps#capturas
        sub#emitir: ast#cuerpo
        sub#emisor#moverAPrograma: sub#númTotalLocales, sub#capturas#longitud
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoIdentificador
        [ Solo maneja los usos de un nombre. Las definiciones son manejadas manualmente ]
        yo#emitirObtenerIdentificador: ast
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoVariable
        [ Nada que hacer: los bloques inicializan las locales ]
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoFijar
        yo#emitir: ast#expresión
        yo#emitirFijarIdentificador: ast#objetivo
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoEscribir
        yo#emitir: ast#expresión
        yo#emisor#emitir: Opcode#prn, yo#cima
        yo#sacar
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoNl
        yo#emisor#emitir: Opcode#prnl
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoNecesitas
        yo#emitir: ast#expresión
        yo#emisor#emitir: Opcode#assert, yo#cima
        yo#sacar
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoDevolver
        yo#emitir: ast#expresión
        yo#emisor#emitir: Opcode#devolverN, (Arreglo#crearCon: (Retorno#crear: FALSO, yo#cima))
        yo#sacar
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoSi
        variables etqSino, etqFinsi, regDet, regTemp
        fijar etqSino a Etiqueta#vacía
        fijar etqFinsi a Etiqueta#vacía

        yo#emitir: ast#condición
        fijar regDet a yo#cima
        fijar regTemp a yo#empujar
        yo#emisor#emitir: Opcode#negar, regTemp, regDet
        yo#emisor#emitir: Opcode#csaltar, etqSino, regTemp
        yo#sacarRegistro: regTemp
        yo#sacarRegistro: regDet
        yo#emitir: ast#cuerpoSiVerdadero
        yo#emisor#emitir: Opcode#saltar, etqFinsi
        yo#emisor#ajustarEtiqueta: etqSino
        yo#emitir: ast#cuerpoSiFalso
        yo#emisor#ajustarEtiqueta: etqFinsi
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoMientras
        variables etqInicio, etqFinmientras, regDet, regTemp
        fijar etqInicio a Etiqueta#vacía
        fijar etqFinmientras a Etiqueta#vacía

        yo#emisor#ajustarEtiqueta: etqInicio
        yo#emitir: ast#condición
        fijar regDet a yo#cima
        fijar regTemp a yo#empujar
        yo#emisor#emitir: Opcode#negar, regTemp, regDet
        yo#emisor#emitir: Opcode#csaltar, etqFinmientras, regTemp
        yo#sacarRegistro: regTemp
        yo#sacarRegistro: regDet
        yo#emitir: ast#cuerpo
        yo#emisor#emitir: Opcode#saltar, etqInicio
        yo#emisor#ajustarEtiqueta: etqFinmientras
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoUtilizar
        variables informaciónDelMódulo, módulo, regMód
        fijar informaciónDelMódulo a yo#tablasRnAst#tablaInformaciónDeMódulo#buscarÚnico: {idNodo}, ast#id
        fijar módulo a yo#bdMod#buscarMódulo: informaciónDelMódulo#paquete, informaciónDelMódulo#módulo

        fijar regMód a yo#empujar
        yo#emisor#emitir: Opcode#importar_s1, regMód, módulo#prefijoDelMódulo
        yo#emisor#emitir: Opcode#importar_s2, regMód, módulo#prefijoDelMódulo
        ParaCadaElemento: ast#nombresEspecíficos, procedimiento: nombreEspecífico
            variable regValor
            fijar regValor a yo#empujar
            yo#emisor#emitir: Opcode#extraer_s1, regValor, regMód, nombreEspecífico#nombre#valor
            yo#emisor#emitir: Opcode#extraer_s2, regValor, regMód, nombreEspecífico#nombre#valor
            yo#emitirFijarIdentificador: nombreEspecífico#renombre
        finprocedimiento

        si no EsNulo: ast#espacioDeNombres
            variable regNs
            fijar regNs a yo#empujar
            yo#emisor#emitir: Opcode#comoEspacioDeNombres, regNs, regMód
            yo#emitirFijarIdentificador: ast#espacioDeNombres
        finsi

        yo#sacarRegistro: regMód

        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoLiteralNumérica
        yo#emisor#emitir: Opcode#número, yo#empujar, ast#valor
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoLiteralTextual
        yo#emisor#emitir: Opcode#texto, yo#empujar, ast#valor
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoEnviarMensaje
        variables regObj, args, regRet, rets
        fijar regRet a yo#empujar
        yo#emitir: ast#objeto
        fijar regObj a yo#cima
        fijar args a Mapear: ast#argumentos, funcion: arg
            yo#emitir: arg#expresión
            devolver Argumento#crear: arg#esVariadic, yo#cima
        finfuncion
        fijar rets a Arreglo#crearCon: (Retorno#crear: FALSO, regRet)
        yo#emisor#emitir: Opcode#enviarMensaje_s1, rets, regObj, ast#mensaje, args
        yo#emisor#emitir: Opcode#enviarMensaje_s2, rets, regObj, ast#mensaje, args
        ParaCadaElementoEnReversa: args, procedimiento: arg
            yo#sacarRegistro: arg#registro
        finprocedimiento
        yo#sacarRegistro: regObj
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoFunciónAnónima
        variables sub, caps, emisor, func, params, regRet, regClz, regsCaps
        fijar emisor a Emisor#subEmisor: yo#emisor
        fijar caps a ObtenerCapturasYLocales: ast, yo#tablasMcAst
        fijar sub a yo#subestado: emisor, caps#locales, caps#capturas

        fijar params a Mapear: ast#parámetros, procedimiento: param
            devolver Parámetro#crear: param#esVariadic, sub#empujar
        finprocedimiento

        ParaCadaElementoEnReversa: ast#parámetros, procedimiento: param
            sub#prepararDeclaración: param#identificador
            sub#emitirFijarIdentificador: param#identificador
        finprocedimiento

        sub#emitir: ast#cuerpo
        fijar regRet a sub#empujar
        sub#emisor#emitir: Opcode#nulo, regRet
        sub#emisor#emitir: Opcode#devolverN, (Arreglo#crearCon: (Retorno#crear: FALSO, regRet))
        sub#sacarRegistro: regRet

        fijar func a sub#emisor#moverAFunción: params, sub#númTotalLocales, sub#capturas#longitud
        fijar regClz a yo#empujar
        fijar regsCaps a Mapear: caps#ordenDeCapturas, procedimiento: binding
            devolver yo#registroDeBinding: binding
        finprocedimiento
        yo#emisor#emitir: Opcode#mkclz, regClz, func#id, regsCaps

        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoNo
        variable reg
        fijar reg a yo#empujar
        yo#emitir: ast#expresión
        yo#emisor#emitir: Opcode#negar, reg, yo#cima
        yo#sacar
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoSonIdénticos
        variable reg
        fijar reg a yo#empujar
        yo#emitir: ast#lhs
        yo#emitir: ast#rhs
        yo#emisor#emitir: Opcode#sonIdénticos, reg, (yo#registroEnLaPila: 1), (yo#registroEnLaPila: 0)
        yo#sacar
        yo#sacar
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoExportar
        variable regNs
        fijar regNs a yo#empujar
        yo#emisor#emitir: Opcode#espacioDeNombres, regNs
        ParaCadaElemento: ast#exportaciones, procedimiento: exp
            necesitas EsInstancia: exp, AST#NodoExportación
            variable regExp
            yo#emitir: exp#expresión
            fijar regExp a yo#cima
            yo#emisor#emitir: Opcode#agregarNombre, regNs, regExp, exp#nombre#valor, exp#esAutoejecutable
            yo#sacarRegistro: regExp
        finprocedimiento
        yo#emisor#emitir: Opcode#exportar, regNs
        yo#sacarRegistro: regNs
        devolver NULO
    finsi

    si EsInstancia: ast, AST#NodoExportación
        Escribir: {Exportación}, ast
        Inalcanzable
    finsi

    si EsInstancia: ast, AST#NodoBuiltin
        si ast#nombre = {objeto}
            yo#emisor#emitir: Opcode#obtenerObjeto, yo#empujar
            devolver NULO
        finsi
        si ast#nombre = {obtenerRuntime}
            yo#emisor#emitir: Opcode#obtenerRuntime, yo#empujar
            devolver NULO
        finsi
        si ast#nombre = {__Impl}
            yo#emisor#emitir: Opcode#texto, yo#empujar, IMPL_COMPILADOR
            devolver NULO
        finsi
        si (ast#nombre#subTexto: 0, 3) = {rt:}
            variables nombre, regRt, args, regRet, rets
            fijar nombre a ast#nombre#parteDelTexto: 3, ast#nombre#longitud
            fijar regRet a yo#empujar
            fijar regRt a yo#empujar
            yo#emisor#emitir: Opcode#obtenerEspacioDeNombresDelRuntime, regRt
            fijar args a Mapear: ast#argumentos, procedimiento: arg
                yo#emitir: arg#expresión
                devolver Argumento#crear: arg#esVariadic, yo#cima
            finprocedimiento
            fijar rets a Arreglo#crearCon: (Retorno#crear: FALSO, regRet)
            yo#emisor#emitir: Opcode#enviarMensaje_s1, rets, regRt, nombre, args
            yo#emisor#emitir: Opcode#enviarMensaje_s2, rets, regRt, nombre, args
            ParaCadaElementoEnReversa: args, procedimiento: arg
                yo#sacarRegistro: arg#registro
            finprocedimiento
            yo#sacarRegistro: regRt
            devolver NULO
        finsi

        Escribir: {Builtin}, ast, ast#áreaTextual
        NoImplementado
    finsi

    Escribir: ast
    Inalcanzable
finmetodo
