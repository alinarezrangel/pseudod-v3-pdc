utilizar bepd/builtins
utilizar bepd/datos/resultado (Resultado)
utilizar bepd/utilidades/texto (TextoContiene)
utilizar bepd/utilidades/texto/ascii (EsDígitoDecimal, LF, CR, HT)

utilizar bepd/x/puerto (TextoComoPuerto, EOF, PuertoDeLectura)
utilizar bepd/x/utf8 (EsSubrogadoAlto, EsSubrogadoBajo, SubrogadoACodepoint, CodepointACodeunit)
utilizar bepd/x/control (Bucle)


[ El parser implementado aquí esta basado en el grammar oficial de JSON de
  https://json.org ]

[DOCUMENTA
@brief{Procesa un @pd{Texto} con un valor JSON a un valor de PseudoD.}

@pd{json} debe ser un @pd{Texto} o un @pd{PuertoDeLectura}. El JSON será leído
desde este argumento.

@devuelve{Un @pd{Resultado} con el resultado de procesar el JSON. Si es OK su
valor será el objeto deserializado, si es un error entonces el error será un
@pd{Texto} con el mensaje de error.}

Los objetos JSON serán deserializados a @pd{Diccionario}s. Los arreglos serán
@pd{Arreglo}s. Los textos, booleanos, números y nulos serán deserializados a
sus respectivos tipos.
DOCUMENTA]
procedimiento DesdeJSON: json
    devolver LlamarConEC: procedimiento: error
        variables puerto, res, c
        si EsInstancia: json, Texto
            fijar puerto a TextoComoPuerto: json
        sino
            fijar puerto a json
        finsi
        fijar res a Resultado#ok: (LeerElemento: puerto, funcion: err
                devolver %error: (Resultado#error: err)
            finfuncion)
        fijar c a puerto#leerCarácter
        si res#esOk && no son identicos c y EOF
            devolver Resultado#error: ({Carácter inesperado ~t}#formatear: c)
        finsi
        devolver res
    finprocedimiento
finprocedimiento

funcion EsEspacio: car
    devolver (car = { }) || (car = LF) || (car = CR) || (car = HT)
finfuncion

procedimiento SaltarEspacios: puerto
    variable car
    fijar car a puerto#leerCarácter
    mientras VERDADERO
        si car = EOF
            devolver NULO
        finsi
        si no EsEspacio: car
            puerto#desleerCarácter
            devolver NULO
        finsi
        fijar car a puerto#leerCarácter
    finmientras
    Inalcanzable
finprocedimiento

procedimiento LeerElemento: puertoDeLectura, error
    SaltarEspacios: puertoDeLectura
    variable r
    fijar r a LeerValor: puertoDeLectura, error
    SaltarEspacios: puertoDeLectura
    devolver r
finprocedimiento

procedimiento LeerValor: puertoDeLectura, error
    variable c
    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi

    si c = {f}
        LeerLiteral: puertoDeLectura, {alse}, {false}, error
        devolver FALSO
    finsi
    si c = {t}
        LeerLiteral: puertoDeLectura, {rue}, {true}, error
        devolver VERDADERO
    finsi
    si c = {n}
        LeerLiteral: puertoDeLectura, {ull}, {null}, error
        devolver NULO
    finsi
    puertoDeLectura#desleerCarácter

    si (EsDígitoDecimal: c) || (c = {-})
        devolver LeerNúmero: puertoDeLectura, error
    finsi
    si c = {"}
        devolver LeerCadena: puertoDeLectura, error
    finsi
    si c = {[}
        devolver LeerArreglo: puertoDeLectura, error
    finsi
    si c = «{»
        devolver LeerObjeto: puertoDeLectura, error
    finsi

    devolver %error: ({Carácter inesperado: ~t}#formatear: c)
finprocedimiento

procedimiento LeerLiteral: puertoDeLectura, literal, nombre, error
    ParaCadaElemento: literal, procedimiento: c
        variable l
        fijar l a puertoDeLectura#leerCarácter
        si son identicos c y EOF
            devolver %error: {Fin del archivo inesperado}
        finsi
        si no c = l
            devolver %error: ({Se esperaba ~t pero se leyó ~t mientras se esperaba ~t}#formatear: c, l, nombre)
        finsi
    finprocedimiento
finprocedimiento

procedimiento LeerDígitos: puertoDeLectura, error
    variables c, número
    fijar número a {}
    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    si no EsDígitoDecimal: c
        devolver %error: ({Se esperaba un dígito decimal, pero se obtuvo ~t}#formatear: c)
    finsi
    LlamarConEC: procedimiento: salir
        mientras EsDígitoDecimal: c
            fijar número a número#concatenar: c
            fijar c a puertoDeLectura#leerCarácter
            si son identicos c y EOF
                %salir: NULO
            finsi
        finmientras
        puertoDeLectura#desleerCarácter
    finprocedimiento
    devolver número
finprocedimiento

procedimiento LeerNúmero: puertoDeLectura, error
    variables c, número
    fijar c a puertoDeLectura#leerCarácter
    fijar número a {}

    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    si c = {-}
        fijar número a {-}
        fijar c a puertoDeLectura#leerCarácter
        si son identicos c y EOF
            devolver %error: {Fin del archivo inesperado}
        finsi
    finsi

    [ 0-o-dígito ]
    si c = {0}
        fijar número a número#concatenar: c
    sino
        LlamarConEC: procedimiento: salir
            mientras EsDígitoDecimal: c
                fijar número a número#concatenar: c
                fijar c a puertoDeLectura#leerCarácter
                si son identicos c y EOF
                    %salir: NULO
                finsi
            finmientras
            puertoDeLectura#desleerCarácter
        finprocedimiento
    finsi

    [ fracción ]
    fijar c a puertoDeLectura#leerCarácter
    si c = {.}
        fijar número a número#concatenar: c
        fijar número a número#concatenar: (LeerDígitos: puertoDeLectura, error)
    sino
        si no son identicos c y EOF
            puertoDeLectura#desleerCarácter
        finsi
    finsi

    [ exponente ]
    fijar c a puertoDeLectura#leerCarácter
    si (c = {e}) || (c = {E})
        fijar número a número#concatenar: c
        fijar c a puertoDeLectura#leerCarácter
        si son identicos c y EOF
            devolver %error: {Fin del archivo inesperado}
        finsi
        si (c = {-}) || (c = {+})
            fijar número a número#concatenar: c
        sino
            si EsDígitoDecimal: c
                puertoDeLectura#desleerCarácter
            sino
                devolver %error: ({Carácter inesperado: ~t}#formatear: c)
            finsi
        finsi
        fijar número a número#concatenar: (LeerDígitos: puertoDeLectura, error)
    sino
        si no son identicos c y EOF
            puertoDeLectura#desleerCarácter
        finsi
    finsi

    devolver número#comoNumeroReal
finprocedimiento

funcion EsCarácterLiteral: c
    devolver (no c = {"}) && (no c = {\})
finfuncion

procedimiento LeerCadena: puertoDeLectura, error
    variables c, texto
    fijar c a puertoDeLectura#leerCarácter
    fijar texto a {}
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi

    si no c = {"}
        devolver %error: ({Se esperaba " (inicio de cadena) pero se encontró ~t}#formatear: c)
    finsi

    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi

    mientras VERDADERO
        mientras EsCarácterLiteral: c
            fijar texto a texto#concatenar: c
            fijar c a puertoDeLectura#leerCarácter
            si son identicos c y EOF
                devolver %error: {Fin del archivo inesperado}
            finsi
        finmientras

        si c = {"}
            devolver texto
        finsi
        si c = {\}
            puertoDeLectura#desleerCarácter

            [ Los escapes unicode son los más complicados: JSON utiliza UTF-16
              pero nosotros usamos UTF-8. Para esto debemos detectar los
              "surrogate-pairs" a mano y convertirlos en sus codepoints expandidos ]
            variable escape
            fijar escape a LeerEscape: puertoDeLectura, error
            Bucle: escape, procedimiento: recur, escape
                si EsInstancia: escape, Numero
                    si EsSubrogadoAlto: escape
                        fijar c a puertoDeLectura#leerCarácter
                        si son identicos c y EOF
                            devolver %error: {Fin del archivo inesperado}
                        finsi
                        puertoDeLectura#desleerCarácter
                        si c = {\}
                            variable sigEscape
                            fijar sigEscape a LeerEscape: puertoDeLectura, error
                            si EsInstancia: sigEscape, Numero
                                si EsSubrogadoBajo: sigEscape
                                    fijar texto a texto#concatenar: (CodepointACodeunit: (SubrogadoACodepoint: escape, sigEscape))
                                sino
                                    fijar texto a texto#concatenar: (CodepointACodeunit: 65533 [0xFFFD])
                                    devolver %recur: sigEscape
                                finsi
                            sino
                                fijar texto a texto#concatenar: (CodepointACodeunit: 65533 [0xFFFD])
                                fijar texto a texto#concatenar: sigEscape
                            finsi
                        sino
                            fijar texto a texto#concatenar: (CodepointACodeunit: 65533 [0xFFFD])
                        finsi
                    sino
                        si EsSubrogadoBajo: escape
                            fijar texto a texto#concatenar: (CodepointACodeunit: 65533 [0xFFFD])
                        sino
                            fijar texto a texto#concatenar: (CodepointACodeunit: escape)
                        finsi
                    finsi
                sino
                    fijar texto a texto#concatenar: escape
                finsi
            finprocedimiento

            fijar c a puertoDeLectura#leerCarácter
            si son identicos c y EOF
                devolver %error: {Fin del archivo inesperado}
            finsi
        finsi
    finmientras
finprocedimiento

procedimiento LeerEscape: puertoDeLectura, error
    variable c, texto
    fijar c a puertoDeLectura#leerCarácter
    fijar texto a {}
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    si no c = {\}
        devolver %error: ({Se esperaba \ pero se obtuvo ~t}#formatear: c)
    finsi

    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi

    si c = {\}
        devolver {\}
    finsi
    si c = {"}
        devolver {"}
    finsi
    si c = {/}
        devolver {/}
    finsi
    si c = {b}
        devolver __ByteATexto: 8
    finsi
    si c = {f}
        devolver __ByteATexto: 12
    finsi
    si c = {n}
        devolver LF
    finsi
    si c = {r}
        devolver CR
    finsi
    si c = {t}
        devolver HT
    finsi

    si c = {u}
        devolver Leer4Hex: puertoDeLectura, error
    finsi

    devolver %error: ({Se esperaba una secuencia de escape pero se obtuvo ~t}#formatear: c)
finprocedimiento

procedimiento Leer4Hex: puertoDeLectura, error
    variable A, B, C, D
    fijar A a puertoDeLectura#leerCarácter
    si son identicos A y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    fijar B a puertoDeLectura#leerCarácter
    si son identicos B y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    fijar C a puertoDeLectura#leerCarácter
    si son identicos C y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    fijar D a puertoDeLectura#leerCarácter
    si son identicos D y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi

    si no EsHexadecimal: A
        devolver %error: ({Se esperaba un carácter hexadecimal pero se obtuvo ~t}#formatear: A)
    finsi
    si no EsHexadecimal: B
        devolver %error: ({Se esperaba un carácter hexadecimal pero se obtuvo ~t}#formatear: A)
    finsi
    si no EsHexadecimal: C
        devolver %error: ({Se esperaba un carácter hexadecimal pero se obtuvo ~t}#formatear: A)
    finsi
    si no EsHexadecimal: D
        devolver %error: ({Se esperaba un carácter hexadecimal pero se obtuvo ~t}#formatear: A)
    finsi

    devolver HexadecimalAEntero: ({~t~t~t~t}#formatear: A, B, C, D)
finprocedimiento


variable ALFABETO_HEX
fijar ALFABETO_HEX a {0123456789abcdefABCDEF}

funcion EsHexadecimal: car
    devolver TextoContiene: ALFABETO_HEX, car
finfuncion

variables DÍGITOS_HEX_MY, DÍGITOS_HEX_MN
fijar DÍGITOS_HEX_MN a {0123456789abcdef}
fijar DÍGITOS_HEX_MY a {0123456789ABCDEF}

funcion DígitoHexAEntero: car
    variable r
    fijar r a DÍGITOS_HEX_MN#buscar: 0, car
    si no EsNulo: r
        devolver r
    finsi
    fijar r a DÍGITOS_HEX_MY#buscar: 0, car
    si no EsNulo: r
        devolver r
    finsi
    __FallarConMensaje: ({Dígito hexadecimal inválido: ~t}#formatear: car)
finfuncion

funcion HexadecimalAEntero: txt
    variable n
    fijar n a 0
    ParaCadaElemento: txt, procedimiento: d
        fijar n a (n << 4) + (DígitoHexAEntero: d)
    finprocedimiento
    devolver n
finfuncion

procedimiento LeerArreglo: puertoDeLectura, error
    variable c
    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    si no c = {[}
        devolver %error: ({Se esperaba [ pero se obtuvo ~t}#formatear: c)
    finsi
    SaltarEspacios: puertoDeLectura

    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    si c = {]}
        devolver Arreglo#vacio
    sino
        puertoDeLectura#desleerCarácter
        variable res
        fijar res a LeerElementos: puertoDeLectura, error
        fijar c a puertoDeLectura#leerCarácter
        si son identicos c y EOF
            devolver %error: {Fin del archivo inesperado}
        finsi
        si c = {]}
            devolver res
        sino
            devolver %error: ({Se esperaba ] pero se obtuvo ~t}#formatear: c)
        finsi
    finsi
finprocedimiento

procedimiento LeerElementos: puertoDeLectura, error
    variables res, c
    fijar res a Arreglo#vacio
    fijar c a {,}
    mientras c = {,}
        res#agregarAlFinal: (LeerElemento: puertoDeLectura, error)
        fijar c a puertoDeLectura#leerCarácter
        si son identicos c y EOF
            devolver %error: {Fin del archivo inesperado}
        finsi
    finmientras
    puertoDeLectura#desleerCarácter
    devolver res
finprocedimiento

procedimiento LeerObjeto: puertoDeLectura, error
    variable c
    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    si no c = «{»
        devolver %error: («Se esperaba { pero se obtuvo ~t»#formatear: c)
    finsi
    SaltarEspacios: puertoDeLectura

    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    si c = «}»
        devolver Diccionario#vacío
    sino
        puertoDeLectura#desleerCarácter
        variable res
        fijar res a LeerMiembros: puertoDeLectura, error
        fijar c a puertoDeLectura#leerCarácter
        si son identicos c y EOF
            devolver %error: {Fin del archivo inesperado}
        finsi
        si c = «}»
            devolver res
        sino
            devolver %error: («Se esperaba } pero se obtuvo ~t»#formatear: c)
        finsi
    finsi
finprocedimiento

procedimiento LeerMiembros: puertoDeLectura, error
    variables res, c
    fijar res a Diccionario#vacío
    fijar c a {,}
    mientras c = {,}
        LeerMiembro: res, puertoDeLectura, error
        fijar c a puertoDeLectura#leerCarácter
        si son identicos c y EOF
            devolver %error: {Fin del archivo inesperado}
        finsi
    finmientras
    puertoDeLectura#desleerCarácter
    devolver res
finprocedimiento

procedimiento LeerMiembro: obj, puertoDeLectura, error
    variables c, llave, valor
    SaltarEspacios: puertoDeLectura
    fijar llave a LeerCadena: puertoDeLectura, error
    SaltarEspacios: puertoDeLectura
    fijar c a puertoDeLectura#leerCarácter
    si son identicos c y EOF
        devolver %error: {Fin del archivo inesperado}
    finsi
    si no c = {:}
        devolver %error: ({Se esperaba : pero se obtuvo ~t}#formatear: c)
    finsi
    fijar valor a LeerElemento: puertoDeLectura, error
    obj#fijarEn: llave, valor
finprocedimiento
